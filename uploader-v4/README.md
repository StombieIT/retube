# uploader-v4

## Роль сервиса

Сервис является частью серверной стороны дипломной работы.
Серверная часть состоит из нескольких микросервисов, каждый из которых выполняет
определенную функциональность, а если обобщить, то на сервере происходит создание,
обработка, кодирование, преобразование в нужные стандарты и протоколы (`DASH`, `HLS`),
которые умеют адаптивно стримить предварительно загруженные видеопотоки, видеоконтента.

Микросервисы взаимодействуют между собой посредством внутренней сети, созданной
в рамках `docker compose` настройки. Поэтому в идеале встроить текущий сервис в
уже имеющуюся инфраструктуру, поэтому при реализации буду исходить из этого и
по возможности везде использовать переменные окружения и абстрагироваться от
непосредственной работы с подключениями.

Основным назначением сервиса `uploader-v4`, если говорить обобщенно,
является реагирование на сообщения из AMQP очереди и их обработка. Сообщения будут
приходить от головного сервиса (`gateway`) в соответствующем строгом формате с хеадерами,
которые размечают соответствующий чанк видео, который необходимо передать в другой сервис
(`fflow`), где происходит "склеивание" видео и преобразование в два стандарта, которые я указал ранее,
и отправка по протоколу `ftp` на микросервис `holder`, который отвечает за хранение
и раздачу статики видео в разных форматах. Чанк видео необходимо провалидировать
и синхронизировать с состоянием в базе данных, дабы избежать неконсистентности.
В качестве БД используется PostgreSQL, а для текущего сервиса интерес представляет
три сущности:
- `Video` - сущность, описывающая видео, которая содержит статус, заголовок, 
описание и прочие данные;
- `Flow` - у каждого видео есть несколько потоков, которые представляют информацию
непосредственно о каждом экземпляре видео, количество загруженных байт, общий размер
видео и текущий статус потока;
- `UploadSession` - сессия загрузки, которая относится один-к-одному к потоку видео.
У каждого потока, когда его статус равняется `UPLOADING` должна содержаться соответствующая
сессия загрузки.

Синхронизацией и контролем состояния видео и соответствующих ему потоков и сессий
загрузки должен заниматься `uploader-v4` - это в зоне ответственности данного сервиса.
Сервис в итоговом проекте будет запущен в нескольких независимых репликах.
Одна из таких реплик будет представлять собой `standalone`, которая также
должна содержать в себе логику шедулера, который будет отслеживать неиспользуемые
видео и сессии загрузки. Поэтому хочу предусмотреть возможность активации режима
шедулера по какой-нибудь переменной окружения. Кроме того, важно также учитывать,
что сервис `fflow`, который содержит в себе процесс склейки и кодирования видео с помощью
`ffmpeg`, состоит из реплик, который порождают в себе эти независимые процессы ффмпега.
Это значит, что после создания такого процесса нужно как-то маршрутизировать соответствующий
чанк видео на нужную реплику. У меня уже реализован этот механизм и он работает
на основе префиксов к основным ручкам сервиса. Каждая реплика при создании процесса
возвращает аплоадеру адрес самой себя, который уникально ее идентифицирует, например `http://localhost:4050/r1/`,
хотя по умолчанию обращение происходит по адресу `http://localhost:4050`.
Чтобы шарить информацию между репликами аплоадера, необходимо использовать механизм
кэширования, и в данном случае для решения поставленной задачи идеально подходит
`Redis`, так как представляет собой систему кэширования `ключ=значение`, которая бы
позволила шарить между репликами соответствие `<id_сессии_загрузки=адрес_реплики_fflow_где_создан_процесс>`
и однозначно идентифицировать сессию загрузки и созданную реплику. Соответственно,
интеграцию с `Redis` тоже нужно будет поддержать.
